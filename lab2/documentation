1. 我是如何处理注释的
由于注释需要支持嵌套注释，所以我在lex开头定义了一个comment_depth的int变量，每当遇到/×符号需要进入注释状态的时候就将这个深度置为1，之后每当遇到一个/×深度就加一，遇到一个×/深度就减一，并判断减完后深度是否大于零。如果是，那么继续COMMENT状态，如果不是，说明左右注释符全部匹配上了，此时退出COMMENT状态，回到NORMAL状态。同时注释字段中遇到换行符则调用EM_newline()然后继续。其余字符直接读取adjust（）略过。

2.我是如何处理String的
当在NORMAL状态中遇到‘”’，则进入STR状态，除非遇到另一个‘“’退出STR状态返回NORMAL，其余情况都保持STR状态。在lex文件的开头我定义了一个缓冲字符数组strbuf[]，用于存储string的值，特殊字符意外的字符直接复制进字符数组末尾，在遇到第二个”后将字符数组的末尾添上一个‘\0’结束符，然后将前面的部分复制进yyval.sval里面。遇到特殊的需要转义的字符按照他的转义后的意义加入字符数组

3.错误处理
errormsg里面定义两种，一个是EM_newline(),另一个是EM_tokPos()。在NORMAl和COMMENT里遇到\n都调用EM_newline()。因为lex的token处理靠前的较为优先，所以我在所有的NORMAL里的token定义完之后在最后面用“.”代表其余的情况（遇到了未定义的字符），并且在这种情况中调用了_tokPos()。

4.文件末尾处理


5.其它
STR状态下遇到 \[ \t\n\f]\时，也就是遇到string中间换行了的情况时直接忽略中间换行的部分
遇到\ddd，也就是三个数字定义的一个ASCII字符时自动转义成对应的ASCII字符
